// module to compare the user switch input to the "random" number
// generated by the LSFR unit. If the switch value is greater than 
// the LSFR value, this is considered a computer button press. 

module CyberPlayer (out, clk, reset, SW, Q);
	
	output logic out;
	input logic clk, reset;
	input logic [9:0] Q;
	input logic [8:0] SW; // holds values of 0-511 depending on what switch is on
	
	logic [9:0] extended_SW;
	assign extended_SW = {1'b0, SW}; // adds zero to the top bit to make the switch
												// number 10 bits
												
	comparator cyberInput(.out, .clk, .reset, .A(extended_SW), .B(Q));
endmodule 


module CyberPlayer_testbench();
	logic out;
	logic clk, reset;
	logic [9:0] extended_SW, Q;
	logic [8:0] SW;
	
	CyberPlayer dut (.out, .clk, .reset, .SW, .Q);
	
	parameter CLOCK_PERIOD = 100;
	initial begin
		clk <= 0;
		forever #(CLOCK_PERIOD / 2) clk <= ~clk; // forever toggle the clock
	end 
	
	initial begin
																				@(posedge clk);
																				@(posedge clk);
		reset <= 1;															@(posedge clk);
																				@(posedge clk);
		reset <= 0;															@(posedge clk);
																				@(posedge clk);
		Q = 10'b0000000001;	SW = 9'b000000010;		         @(posedge clk);
																				@(posedge clk);
		Q = 10'b0000000011;												@(posedge clk);
																				@(posedge clk);
																				@(posedge clk);
									SW = 9'b000001111;    	         @(posedge clk);
																				@(posedge clk);
																				@(posedge clk);
																				@(posedge clk);
		$stop;
	end
endmodule 
	